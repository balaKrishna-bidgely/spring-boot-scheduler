name: Run Spring Boot Application

on:
  workflow_dispatch:  # Manual trigger
    inputs:
      duration_minutes:
        description: 'Duration to run the app (in minutes)'
        required: true
        default: '60'
  # schedule:
  #   - cron: '0 */6 * * *'  # Optional: Run every 6 hours

jobs:
  run-application:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: postgres
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: 1234
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn clean package -DskipTests

      - name: Start Spring Boot Application
        run: |
          echo "Starting Spring Boot application..."
          echo "Logs will be written to app.log"

          # Start the application and redirect output to app.log
          nohup java -jar target/*.jar > app.log 2>&1 &
          APP_PID=$!
          echo "APP_PID=$APP_PID" >> $GITHUB_ENV
          echo "Application started with PID: $APP_PID"

          # Wait a moment for the log file to be created
          sleep 3

          # Show initial logs
          echo ""
          echo "=========================================="
          echo "üìã Initial Application Output:"
          echo "=========================================="
          if [ -f app.log ]; then
            head -n 20 app.log
          else
            echo "‚ö†Ô∏è  Log file not created yet"
          fi
          echo "=========================================="
        env:
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/postgres
          SPRING_DATASOURCE_USERNAME: postgres
          SPRING_DATASOURCE_PASSWORD: 1234

      - name: Wait for application to start
        run: |
          echo "Waiting for application to be ready..."
          echo ""

          # Check if app process is running
          if ! ps -p $APP_PID > /dev/null; then
            echo "‚ùå ERROR: Application process died immediately!"
            echo ""
            echo "Application logs:"
            cat app.log 2>/dev/null || echo "No log file found"
            exit 1
          fi

          for i in {1..30}; do
            # Check if process is still alive
            if ! ps -p $APP_PID > /dev/null; then
              echo ""
              echo "‚ùå ERROR: Application process died during startup!"
              echo ""
              echo "=========================================="
              echo "üìã FULL APPLICATION LOG:"
              echo "=========================================="
              cat app.log 2>/dev/null || echo "No log file found"
              echo "=========================================="
              exit 1
            fi

            # Try to connect to the application
            if curl -f http://localhost:8080/actuator/health 2>/dev/null || curl -f http://localhost:8080 2>/dev/null; then
              echo ""
              echo "Application is ready!"
              echo ""
              echo "=========================================="
              echo "üìã STARTUP LOGS (Last 50 lines):"
              echo "=========================================="
              tail -n 50 app.log 2>/dev/null || echo "No log file found"
              echo "=========================================="
              break
            fi

            echo "Attempt $i/30: Application not ready yet, waiting..."

            # Show logs at intervals
            if [ $i -eq 10 ] || [ $i -eq 20 ]; then
              echo ""
              echo "=========================================="
              echo "üìã Current application logs (last 30 lines):"
              echo "=========================================="
              if [ -f app.log ]; then
                tail -n 30 app.log
              else
                echo "‚ö†Ô∏è  Log file 'app.log' not found yet"
                echo "Checking if process is writing to stdout..."
                ps -p $APP_PID -o pid,command
              fi
              echo "=========================================="
              echo ""
            fi

            # On last attempt, show full logs
            if [ $i -eq 30 ]; then
              echo ""
              echo "‚ùå ERROR: Application failed to start after 150 seconds"
              echo ""
              echo "=========================================="
              echo "üìã FULL APPLICATION LOG:"
              echo "=========================================="
              cat app.log 2>/dev/null || echo "No log file found"
              echo "=========================================="
              echo ""
              echo "Process status:"
              ps -p $APP_PID -o pid,ppid,stat,command || echo "Process not found"
              exit 1
            fi

            sleep 5
          done

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Setup tunnel service
        run: |
          if [ ! -z "${{ secrets.NGROK_AUTH_TOKEN }}" ]; then
            echo "Using ngrok (authenticated)..."
            curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
            echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
            sudo apt update && sudo apt install ngrok
            ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
            echo "TUNNEL_TYPE=ngrok" >> $GITHUB_ENV
          else
            echo "Using localhost.run (no auth required)..."
            echo "TUNNEL_TYPE=localhost.run" >> $GITHUB_ENV
          fi

      - name: Start tunnel
        run: |
          if [ "$TUNNEL_TYPE" = "ngrok" ]; then
            echo "Starting ngrok tunnel..."
            ngrok http 8080 --log=stdout > tunnel.log &
            TUNNEL_PID=$!
            echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV
            sleep 5
            TUNNEL_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
          else
            echo "Starting localhost.run tunnel..."
            # Use localhost.run (SSH-based tunnel, no signup needed)
            ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R 80:localhost:8080 nokey@localhost.run > tunnel.log 2>&1 &
            TUNNEL_PID=$!
            echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV

            # Wait for tunnel to establish and extract URL
            sleep 10
            TUNNEL_URL=$(grep -oP 'https://[a-z0-9-]+\.lhr\.life' tunnel.log | head -1)

            # If localhost.run URL not found, try alternative format
            if [ -z "$TUNNEL_URL" ]; then
              TUNNEL_URL=$(grep -oP 'tunneled.*https://\K[^\s]+' tunnel.log | head -1)
            fi

            # Fallback: show what we got
            if [ -z "$TUNNEL_URL" ]; then
              echo "Could not extract URL automatically. Tunnel log:"
              cat tunnel.log
              TUNNEL_URL="Check logs for URL"
            fi
          fi

          echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
          echo "tunnel_url=$TUNNEL_URL" >> $GITHUB_OUTPUT
          echo "Public URL: $TUNNEL_URL"
        id: tunnel

      - name: Display application info
        run: |
          echo "==================================="
          echo "üöÄ Application is running!"
          echo "==================================="
          echo "Public URL: ${{ env.TUNNEL_URL }}"
          echo "Duration: ${{ github.event.inputs.duration_minutes || '60' }} minutes"
          echo "Started at: $(date)"
          echo "Will stop at: $(date -d '+${{ github.event.inputs.duration_minutes || '60' }} minutes')"
          echo "==================================="
          echo ""
          echo "üì° API Endpoints:"
          echo "  - Health: ${{ env.TUNNEL_URL }}/actuator/health"
          echo "  - Rates: ${{ env.TUNNEL_URL }}/api/rates"
          echo "  - Notifications: ${{ env.TUNNEL_URL }}/api/notifications"
          echo "  - Templates: ${{ env.TUNNEL_URL }}/api/templates"
          echo "==================================="
          echo ""
          echo "üí° Example API Requests:"
          echo "  curl ${{ env.TUNNEL_URL }}/api/rates"
          echo "  curl ${{ env.TUNNEL_URL }}/api/rates/EUR"
          echo "==================================="

      - name: Create GitHub Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # üöÄ Application Running Successfully!

          ## üåê Public URL
          **Your application is accessible at:**
          \`\`\`
          ${{ env.TUNNEL_URL }}
          \`\`\`

          ## ‚è±Ô∏è Runtime Information
          - **Duration:** ${{ github.event.inputs.duration_minutes || '60' }} minutes
          - **Started at:** $(date)
          - **Will stop at:** $(date -d '+${{ github.event.inputs.duration_minutes || '60' }} minutes')
          - **Tunnel Type:** ${{ env.TUNNEL_TYPE }}

          ## üì° Available API Endpoints

          | Endpoint | URL |
          |----------|-----|
          | Health Check | [\`GET ${{ env.TUNNEL_URL }}/actuator/health\`](${{ env.TUNNEL_URL }}/actuator/health) |
          | Get All Rates | [\`GET ${{ env.TUNNEL_URL }}/api/rates\`](${{ env.TUNNEL_URL }}/api/rates) |
          | Get Rate by Currency | [\`GET ${{ env.TUNNEL_URL }}/api/rates/{currency}\`](${{ env.TUNNEL_URL }}/api/rates/EUR) |
          | Create Notification | [\`POST ${{ env.TUNNEL_URL }}/api/notifications\`](${{ env.TUNNEL_URL }}/api/notifications) |
          | Get Notification | [\`GET ${{ env.TUNNEL_URL }}/api/notifications/{id}\`](${{ env.TUNNEL_URL }}/api/notifications/1) |
          | List Notifications | [\`GET ${{ env.TUNNEL_URL }}/api/notifications\`](${{ env.TUNNEL_URL }}/api/notifications) |
          | Get All Templates | [\`GET ${{ env.TUNNEL_URL }}/api/templates\`](${{ env.TUNNEL_URL }}/api/templates) |

          ## üí° Example cURL Commands

          ### Get Exchange Rates
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/rates
          \`\`\`

          ### Get Specific Currency Rate
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/rates/EUR
          \`\`\`

          ### Create a Notification Job
          \`\`\`bash
          curl -X POST ${{ env.TUNNEL_URL }}/api/notifications \\
            -H "Content-Type: application/json" \\
            -d '{
              "userId": 1,
              "type": "EMAIL",
              "templateKey": "welcome",
              "sendAt": "$(date -u -d '+5 minutes' +%Y-%m-%dT%H:%M:%S)",
              "data": {
                "userName": "John Doe",
                "orderId": "12345"
              }
            }'
          \`\`\`

          ### List All Notifications
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/notifications
          \`\`\`

          ### Get Templates
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/templates
          \`\`\`

          ---

          **Note:** The application will automatically stop after ${{ github.event.inputs.duration_minutes || '60' }} minutes.
          EOF

      - name: Run application for specified duration
        run: |
          DURATION_MINUTES=${{ github.event.inputs.duration_minutes || '60' }}
          DURATION_SECONDS=$((DURATION_MINUTES * 60))
          echo "Running application for $DURATION_MINUTES minutes ($DURATION_SECONDS seconds)..."
          echo ""
          echo "üåê Your application is now accessible at: ${{ env.TUNNEL_URL }}"
          echo ""
          echo "=========================================="
          echo "üìã SPRING BOOT APPLICATION LOGS"
          echo "=========================================="
          echo ""

          # Monitor the application while it runs
          END_TIME=$(($(date +%s) + DURATION_SECONDS))
          LAST_LOG_LINE=0

          while [ $(date +%s) -lt $END_TIME ]; do
            REMAINING=$((END_TIME - $(date +%s)))
            REMAINING_MINUTES=$((REMAINING / 60))
            REMAINING_SECONDS=$((REMAINING % 60))

            # Check if app is still alive
            if ! ps -p $APP_PID > /dev/null; then
              echo ""
              echo "‚ùå ERROR: Application process died!"
              echo ""
              echo "=========================================="
              echo "üìã LAST 100 LINES OF APPLICATION LOG:"
              echo "=========================================="
              tail -n 100 app.log
              exit 1
            fi

            # Check if tunnel is still alive
            if ! ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "‚ö†Ô∏è  WARNING: Tunnel died! Attempting to restart..."
              if [ "$TUNNEL_TYPE" = "ngrok" ]; then
                ngrok http 8080 --log=stdout > tunnel.log &
                TUNNEL_PID=$!
                sleep 3
              else
                ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R 80:localhost:8080 nokey@localhost.run > tunnel.log 2>&1 &
                TUNNEL_PID=$!
                sleep 5
              fi
              echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV
            fi

            # Display status and new logs
            echo ""
            echo "=========================================="
            echo "‚è±Ô∏è  Time remaining: ${REMAINING_MINUTES}m ${REMAINING_SECONDS}s"
            echo "üåê Public URL: ${{ env.TUNNEL_URL }}"
            echo "=========================================="

            # Show NEW log lines since last check
            if [ -f app.log ]; then
              CURRENT_LINES=$(wc -l < app.log 2>/dev/null || echo "0")
              if [ $CURRENT_LINES -gt $LAST_LOG_LINE ]; then
                NEW_LINES=$((CURRENT_LINES - LAST_LOG_LINE))
                echo "üìã New application logs (last $NEW_LINES lines):"
                echo "------------------------------------------"
                tail -n $NEW_LINES app.log
                echo "------------------------------------------"
                LAST_LOG_LINE=$CURRENT_LINES
              else
                echo "üìã No new logs in the last minute"
                echo "(Application is idle or logs are not being written)"
              fi
            else
              echo "‚ö†Ô∏è  app.log file not found"
            fi
            echo ""

            # Sleep for 1 minute between status updates
            sleep 60
          done

          echo "‚úÖ Duration completed!"

      - name: Show final application logs
        if: always()
        run: |
          echo ""
          echo "=========================================="
          echo "üìã FINAL APPLICATION LOGS (Last 200 lines)"
          echo "=========================================="
          if [ -f app.log ]; then
            tail -n 200 app.log
          else
            echo "No application logs found"
          fi
          echo "=========================================="
          echo ""
          echo "üìä Log Statistics:"
          if [ -f app.log ]; then
            echo "Total log lines: $(wc -l < app.log)"
            echo "Log file size: $(du -h app.log | cut -f1)"
            echo ""
            echo "Error count: $(grep -i "error" app.log | wc -l)"
            echo "Warning count: $(grep -i "warn" app.log | wc -l)"
            echo "Exception count: $(grep -i "exception" app.log | wc -l)"
            echo ""
            echo "Recent errors (if any):"
            grep -i "error\|exception" app.log | tail -n 10 || echo "No errors found"
          fi
          echo "=========================================="

      - name: Stop tunnel
        if: always()
        run: |
          if [ ! -z "$TUNNEL_PID" ] && ps -p $TUNNEL_PID > /dev/null 2>&1; then
            echo "Stopping tunnel..."
            kill $TUNNEL_PID 2>/dev/null || true
          fi

      - name: Stop application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ] && ps -p $APP_PID > /dev/null; then
            echo "Stopping application (PID: $APP_PID)..."
            kill $APP_PID
            sleep 5
            # Force kill if still running
            if ps -p $APP_PID > /dev/null; then
              kill -9 $APP_PID
            fi
            echo "Application stopped."
          else
            echo "Application already stopped."
          fi

