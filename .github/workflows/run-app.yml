name: Run Spring Boot Application

on:
  workflow_dispatch:  # Manual trigger
    inputs:
      duration_minutes:
        description: 'Duration to run the app (in minutes)'
        required: true
        default: '60'
  # schedule:
  #   - cron: '0 */6 * * *'  # Optional: Run every 6 hours

jobs:
  run-application:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: postgres
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: 1234
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn clean package -DskipTests

      - name: Start Spring Boot Application
        run: |
          echo "Starting Spring Boot application..."
          java -jar target/*.jar &
          APP_PID=$!
          echo "APP_PID=$APP_PID" >> $GITHUB_ENV
          echo "Application started with PID: $APP_PID"
        env:
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/postgres
          SPRING_DATASOURCE_USERNAME: postgres
          SPRING_DATASOURCE_PASSWORD: 1234

      - name: Wait for application to start
        run: |
          echo "Waiting for application to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:8080/actuator/health 2>/dev/null || curl -f http://localhost:8080 2>/dev/null; then
              echo "Application is ready!"
              break
            fi
            echo "Attempt $i: Application not ready yet, waiting..."
            sleep 5
          done

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Setup tunnel service
        run: |
          if [ ! -z "${{ secrets.NGROK_AUTH_TOKEN }}" ]; then
            echo "Using ngrok (authenticated)..."
            curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
            echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
            sudo apt update && sudo apt install ngrok
            ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
            echo "TUNNEL_TYPE=ngrok" >> $GITHUB_ENV
          else
            echo "Using localhost.run (no auth required)..."
            echo "TUNNEL_TYPE=localhost.run" >> $GITHUB_ENV
          fi

      - name: Start tunnel
        run: |
          if [ "$TUNNEL_TYPE" = "ngrok" ]; then
            echo "Starting ngrok tunnel..."
            ngrok http 8080 --log=stdout > tunnel.log &
            TUNNEL_PID=$!
            echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV
            sleep 5
            TUNNEL_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
          else
            echo "Starting localhost.run tunnel..."
            # Use localhost.run (SSH-based tunnel, no signup needed)
            ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R 80:localhost:8080 nokey@localhost.run > tunnel.log 2>&1 &
            TUNNEL_PID=$!
            echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV

            # Wait for tunnel to establish and extract URL
            sleep 10
            TUNNEL_URL=$(grep -oP 'https://[a-z0-9-]+\.lhr\.life' tunnel.log | head -1)

            # If localhost.run URL not found, try alternative format
            if [ -z "$TUNNEL_URL" ]; then
              TUNNEL_URL=$(grep -oP 'tunneled.*https://\K[^\s]+' tunnel.log | head -1)
            fi

            # Fallback: show what we got
            if [ -z "$TUNNEL_URL" ]; then
              echo "Could not extract URL automatically. Tunnel log:"
              cat tunnel.log
              TUNNEL_URL="Check logs for URL"
            fi
          fi

          echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
          echo "tunnel_url=$TUNNEL_URL" >> $GITHUB_OUTPUT
          echo "Public URL: $TUNNEL_URL"
        id: tunnel

      - name: Display application info
        run: |
          echo "==================================="
          echo "ðŸš€ Application is running!"
          echo "==================================="
          echo "Public URL: ${{ env.TUNNEL_URL }}"
          echo "Duration: ${{ github.event.inputs.duration_minutes || '60' }} minutes"
          echo "Started at: $(date)"
          echo "Will stop at: $(date -d '+${{ github.event.inputs.duration_minutes || '60' }} minutes')"
          echo "==================================="
          echo ""
          echo "ðŸ“¡ API Endpoints:"
          echo "  - Health: ${{ env.TUNNEL_URL }}/actuator/health"
          echo "  - Rates: ${{ env.TUNNEL_URL }}/api/rates"
          echo "  - Notifications: ${{ env.TUNNEL_URL }}/api/notifications"
          echo "  - Templates: ${{ env.TUNNEL_URL }}/api/templates"
          echo "==================================="
          echo ""
          echo "ðŸ’¡ Example API Requests:"
          echo "  curl ${{ env.TUNNEL_URL }}/api/rates"
          echo "  curl ${{ env.TUNNEL_URL }}/api/rates/EUR"
          echo "==================================="

      - name: Create GitHub Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸš€ Application Running Successfully!

          ## ðŸŒ Public URL
          **Your application is accessible at:**
          \`\`\`
          ${{ env.TUNNEL_URL }}
          \`\`\`

          ## â±ï¸ Runtime Information
          - **Duration:** ${{ github.event.inputs.duration_minutes || '60' }} minutes
          - **Started at:** $(date)
          - **Will stop at:** $(date -d '+${{ github.event.inputs.duration_minutes || '60' }} minutes')
          - **Tunnel Type:** ${{ env.TUNNEL_TYPE }}

          ## ðŸ“¡ Available API Endpoints

          | Endpoint | URL |
          |----------|-----|
          | Health Check | [\`GET ${{ env.TUNNEL_URL }}/actuator/health\`](${{ env.TUNNEL_URL }}/actuator/health) |
          | Get All Rates | [\`GET ${{ env.TUNNEL_URL }}/api/rates\`](${{ env.TUNNEL_URL }}/api/rates) |
          | Get Rate by Currency | [\`GET ${{ env.TUNNEL_URL }}/api/rates/{currency}\`](${{ env.TUNNEL_URL }}/api/rates/EUR) |
          | Create Notification | [\`POST ${{ env.TUNNEL_URL }}/api/notifications\`](${{ env.TUNNEL_URL }}/api/notifications) |
          | Get Notification | [\`GET ${{ env.TUNNEL_URL }}/api/notifications/{id}\`](${{ env.TUNNEL_URL }}/api/notifications/1) |
          | List Notifications | [\`GET ${{ env.TUNNEL_URL }}/api/notifications\`](${{ env.TUNNEL_URL }}/api/notifications) |
          | Get All Templates | [\`GET ${{ env.TUNNEL_URL }}/api/templates\`](${{ env.TUNNEL_URL }}/api/templates) |

          ## ðŸ’¡ Example cURL Commands

          ### Get Exchange Rates
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/rates
          \`\`\`

          ### Get Specific Currency Rate
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/rates/EUR
          \`\`\`

          ### Create a Notification Job
          \`\`\`bash
          curl -X POST ${{ env.TUNNEL_URL }}/api/notifications \\
            -H "Content-Type: application/json" \\
            -d '{
              "userId": 1,
              "type": "EMAIL",
              "templateKey": "welcome",
              "sendAt": "$(date -u -d '+5 minutes' +%Y-%m-%dT%H:%M:%S)",
              "data": {
                "userName": "John Doe",
                "orderId": "12345"
              }
            }'
          \`\`\`

          ### List All Notifications
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/notifications
          \`\`\`

          ### Get Templates
          \`\`\`bash
          curl ${{ env.TUNNEL_URL }}/api/templates
          \`\`\`

          ---

          **Note:** The application will automatically stop after ${{ github.event.inputs.duration_minutes || '60' }} minutes.
          EOF

      - name: Run application for specified duration
        run: |
          DURATION_MINUTES=${{ github.event.inputs.duration_minutes || '60' }}
          DURATION_SECONDS=$((DURATION_MINUTES * 60))
          echo "Running application for $DURATION_MINUTES minutes ($DURATION_SECONDS seconds)..."
          echo ""
          echo "ðŸŒ Your application is now accessible at: ${{ env.TUNNEL_URL }}"
          echo "ðŸ“Š Monitor requests in real-time in the logs below"
          echo ""

          # Monitor the application while it runs
          END_TIME=$(($(date +%s) + DURATION_SECONDS))
          while [ $(date +%s) -lt $END_TIME ]; do
            REMAINING=$((END_TIME - $(date +%s)))
            REMAINING_MINUTES=$((REMAINING / 60))
            REMAINING_SECONDS=$((REMAINING % 60))
            echo "â±ï¸  Application running... Time remaining: ${REMAINING_MINUTES}m ${REMAINING_SECONDS}s | Public URL: ${{ env.TUNNEL_URL }}"

            # Check if app is still alive
            if ! ps -p $APP_PID > /dev/null; then
              echo "âŒ ERROR: Application process died!"
              exit 1
            fi

            # Check if tunnel is still alive
            if ! ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "âš ï¸  WARNING: Tunnel died! Attempting to restart..."
              if [ "$TUNNEL_TYPE" = "ngrok" ]; then
                ngrok http 8080 --log=stdout > tunnel.log &
                TUNNEL_PID=$!
                sleep 3
              else
                ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R 80:localhost:8080 nokey@localhost.run > tunnel.log 2>&1 &
                TUNNEL_PID=$!
                sleep 5
              fi
              echo "TUNNEL_PID=$TUNNEL_PID" >> $GITHUB_ENV
            fi

            # Sleep for 1 minute between status updates
            sleep 60
          done

          echo "âœ… Duration completed!"

      - name: Fetch application logs
        if: always()
        run: |
          echo "==================================="
          echo "Application Logs:"
          echo "==================================="
          # If you're logging to a file, cat it here
          # cat logs/application.log || echo "No log file found"

      - name: Stop ngrok
        if: always()
        run: |
          if [ ! -z "$NGROK_PID" ] && ps -p $NGROK_PID > /dev/null; then
            echo "Stopping ngrok tunnel..."
            kill $NGROK_PID 2>/dev/null || true
          fi

      - name: Stop application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ] && ps -p $APP_PID > /dev/null; then
            echo "Stopping application (PID: $APP_PID)..."
            kill $APP_PID
            sleep 5
            # Force kill if still running
            if ps -p $APP_PID > /dev/null; then
              kill -9 $APP_PID
            fi
            echo "Application stopped."
          else
            echo "Application already stopped."
          fi

      - name: Upload logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: application-logs
          path: |
            logs/
            *.log
          retention-days: 7

